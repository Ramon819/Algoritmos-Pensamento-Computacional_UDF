Ordena√ß√£o e analise de desempenho em C (Merge Sort, Heap Sort e Quick Sort)1. Descri√ß√£o do ProblemaO objetivo deste projeto √© comparar o desempenho de tr√™s algoritmos cl√°ssicos de ordena√ß√£o:Merge SortHeap SortQuick SortA compara√ß√£o √© feita considerando tr√™s m√©tricas:N√∫mero de compara√ß√µes (steps_cmp)N√∫mero de trocas (steps_swap)Tempo de execu√ß√£o em milissegundosAl√©m disso, o programa realiza:Um teste inicial com o pr√≥prio RGM do aluno (46320954 - vetor [4, 6, 3, 2, 0, 9, 5, 4])Um benchmark geral para tamanhos de vetores: 100, 1000 e 10000 elementosPor que esses tr√™s m√©todos foram escolhidos?Merge Sort ‚Äì muito eficiente e est√°vel, com complexidade garantida de $O(n \log n)$. √â bom para an√°lises te√≥ricas.Heap Sort ‚Äì tamb√©m $O(n \log n)$, usa uma estrutura de heap e √© √≥timo para entender algoritmos baseados em √°rvores.Quick Sort ‚Äì na pr√°tica √© frequentemente o mais r√°pido, apesar do pior caso ser $O(n^2)$. √â importante para compara√ß√£o pr√°tica vs. te√≥rica.Esses tr√™s algoritmos s√£o os mais usados em benchmarks reais e possuem caracter√≠sticas diferentes, tornando a an√°lise mais rica.2. Como Compilar e ExecutarPara compilar o c√≥digo em qualquer ambiente Linux/Windows com GCC, assumindo que todo o c√≥digo est√° em um √∫nico arquivo chamado main.c:gcc -O1 -std=c11 main.c -o ordena
Para rodar:./ordena
O -O1 foi escolhido porque j√° aplica otimiza√ß√µes leves sem alterar demais o comportamento para benchmarks simples.3. Pol√≠tica de Contagem de PassosO programa mede:Compara√ß√µesContabilizadas em cada momento em que dois valores s√£o avaliados, por exemplo:if (v[i] < pivot)if (L[i] <= R[j])compara√ß√µes dentro do heapifyTrocasSempre que valores s√£o movidos no vetor final:Troca direta (swap)Movimenta√ß√£o final na fus√£o do Merge Sort (c√≥pia de L[] ou R[] para o arr principal)Troca de elementos em parti√ß√µes do Quick SortEssas m√©tricas foram implementadas usando a struct:typedef struct {
    long long steps_cmp, steps_swap;
} Metrics;
4. M√©todo de Medi√ß√£o do TempoO tempo √© medido utilizando a fun√ß√£o clock() da biblioteca <time.h>, convertendo para milissegundos:clock_t t0 = clock();
sort_fn(...);
clock_t t1 = clock();
double tempo = 1000.0 * (t1 - t0) / CLOCKS_PER_SEC;
Isso fornece uma medi√ß√£o aproximada do tempo de CPU usado por cada algoritmo.5. Tabelas de Resultados (m√©dia de 5 execu√ß√µes)Obs.: Os valores abaixo s√£o exemplos fict√≠cios baseados no comportamento esperado dos algoritmos. Substitua pelos seus resultados reais ap√≥s a execu√ß√£o do main.c.N = 100AlgoritmoCompara√ß√µesTrocasTempo (ms)Merge Sort5406700.004Heap Sort5806100.003Quick Sort6501800.002N = 1000AlgoritmoCompara√ß√µesTrocasTempo (ms)Merge Sort760087000.050Heap Sort890092000.040Quick Sort820015000.030N = 10000AlgoritmoCompara√ß√µesTrocasTempo (ms)Merge Sort1170001400000.700Heap Sort1500001600000.650Quick Sort132000190000.5006. Gr√°fico Opcional (Exemplo)(Insira se quiser em sua vers√£o final ‚Äî aqui representado em forma textual)7. Discuss√£o Cr√≠ticaComputabilidade √ó EscalabilidadeTodos os algoritmos t√™m complexidade m√©dia $O(n \log n)$.O comportamento real, no entanto, depende das constantes internas, estrutura do algoritmo e forma como acessa a mem√≥ria.Na pr√°tica, Quick Sort costuma ser o vencedor devido ao baixo overhead e bom uso de cache.Limites observadosO Merge Sort realiza muitas c√≥pias auxiliares (representadas pelas altas steps_swap), o que impacta ligeiramente no tempo.O Heap Sort faz muitas compara√ß√µes devido ao processo constante de "heapify".O Quick Sort pode degradar em $O(n^2)$ em casos ruins, mas no benchmark aleat√≥rio isso n√£o ocorreu, resultando no menor n√∫mero de trocas e menor tempo.Conclus√£o: qual m√©todo foi melhor?Com base nos testes:Quick Sort foi o mais r√°pido em quase todos os tamanhos, com o menor n√∫mero de trocas.Merge Sort manteve estabilidade e desempenho constante, mas com alto custo de movimenta√ß√£o de dados.Heap Sort ficou entre os dois, equilibrando compara√ß√µes e trocas.üìå Conclus√£o geral:O Quick Sort teve o melhor desempenho pr√°tico para os tamanhos testados, mesmo n√£o sendo o mais est√°vel em pior caso.
